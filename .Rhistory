#plot the gam smooths predicting F1/F2 per vowel and add the speaker intercepts values
sound_change_plot_smooth <- mod_pred_yob_values %>%
mutate(Formant = factor(Formant, levels = c("F2", "F1")))  %>%
ggplot(aes(x = Decade, y = fit, colour = Formant, fill = Formant)) +
# individual data points
geom_point(data = gam_intercepts.tmp_long %>% mutate(Formant = factor(Formant, levels = c("F2", "F1"))), aes(x = Decade, y = fit + Intercept), size = 0.25, alpha = 0.1) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = ll, ymax = ul), alpha = 0.2, colour = NA) +
scale_x_continuous(breaks = c(1940, 2000)) +
xlab("Decade") +
ylab("Predicted model fit (Lobanov)") +
facet_grid(Formant~Vowel) +
theme_bw() +
theme(legend.position = "none", axis.text = element_text(size = 12), axis.title = element_text(size = 14, face = "bold"), strip.text = element_text(size = 12, face = "bold"))
sound_change_plot_smooth
#make vector containing all .rds filenames from model_summaries folder
model_summary_files = list.files(pattern="*.rds", path = "model_summaries")
#create a dummy data frame to store the values from plot_smooth
mod_pred_yob_values <- data.frame(plot_smooth(gam_F1_aː, view="Decade", rm.ranef=T)$fv) %>%
mutate(model1 = "gam_F1_aː1") %>%
filter(model1 != "gam_F1_aː1")
#load each of the files with for loop
for (i in model_summary_files) {
#remove .rds from model name and then print the model name
mod1 <- gsub(".rds", "", i)
print(mod1)
#generate a plot smooth of the model giving the participant year of birth smooth
plot1 <- plot_smooth(get(mod1), view="Decade", rm.ranef = T, n.grid = 61, main = mod1)
#extract the values from the plot and reformat for ggplot
plot1 <- plot1$fv %>%
mutate(Vowel = substr(mod1, 8, nchar(mod1)),
Formant = substr(mod1, 5, 6))
#combine the data to the previous rows, so that all models are in a single data frame
mod_pred_yob_values <<- rbind(mod_pred_yob_values, plot1)
}
saveRDS(mod_pred_yob_values, "Models/mod_pred_yob_values.rds")
mod_pred_yob_values <- readRDS("Models/mod_pred_yob_values.rds")
#make a long version of the intercepts
gam_intercepts.tmp_long <- gam_intercepts.tmp %>%
pivot_longer(F1_aː:F2_ɑɪ, names_to = "Vowel_formant", values_to = "Intercept") %>%
mutate(Formant = substr(Vowel_formant, 1, 2),
Vowel = substr(Vowel_formant, 4, max(nchar(Vowel_formant)))) %>%
left_join(vowels_all %>%
select(Speaker, Decade, Gender) %>% distinct()) %>%
left_join(mod_pred_yob_values %>% select(Decade, Vowel, Formant, fit, ll, ul))
#plot the gam smooths predicting F1/F2 per vowel and add the speaker intercepts values
sound_change_plot_smooth <- mod_pred_yob_values %>%
mutate(Formant = factor(Formant, levels = c("F2", "F1")))  %>%
ggplot(aes(x = Decade, y = fit, colour = Formant, fill = Formant)) +
# individual data points
geom_point(data = gam_intercepts.tmp_long %>% mutate(Formant = factor(Formant, levels = c("F2", "F1"))), aes(x = Decade, y = fit + Intercept), size = 0.25, alpha = 0.1) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = ll, ymax = ul), alpha = 0.2, colour = NA) +
scale_x_continuous(breaks = c(1940, 2000)) +
xlab("Decade") +
ylab("Predicted model fit (Lobanov)") +
facet_grid(Formant~Vowel) +
theme_bw() +
theme(legend.position = "none", axis.text = element_text(size = 12), axis.title = element_text(size = 14, face = "bold"), strip.text = element_text(size = 12, face = "bold"))
sound_change_plot_smooth
#make vector containing all .rds filenames from model_summaries folder
model_summary_files = list.files(pattern="*.rds", path = "model_summaries")
#create a dummy data frame to store the values from plot_smooth
mod_pred_yobgender_values <- data.frame(plot_smooth(gam_F1_aː, view="Decade", rm.ranef=T)$fv) %>%
mutate(model1 = "gam_F1_aː1") %>%
filter(model1 != "gam_F1_aː1")
#load each of the files with for loop
for (i in model_summary_files) {
#remove .rds from model name and then print the model name
mod1 <- gsub(".rds", "", i)
print(mod1)
#generate a plot smooth of the model giving the participant Decade*gender interaction smooth
# the n.grid value corresponds to the time span of the sample (years)
# 1943 to 2013: 70
plot1 <- plot_smooth(get(mod1), view="Decade", plot_all = "Gender", n.grid = 61, rm.ranef = T, main = mod1)
#extract the values from the plot and reformat for ggplot
plot1 <- plot1$fv %>%
mutate(Vowel = substr(mod1, 8, nchar(mod1)),
Formant = substr(mod1, 5, 6))
#combine the data to the previous rows, so that all models are in a single data frame
mod_pred_yobgender_values <<- rbind(mod_pred_yobgender_values, plot1)
}
saveRDS(mod_pred_yobgender_values, "Models/mod_pred_yobgender_values.rds")
mod_pred_yobgender_values <- readRDS("Models/mod_pred_yobgender_values.rds")
#plot the gam smooths predicting F1/F2 per vowel and add the per speaker mean values with F or M as the text
sound_change_plot_smooth_gender <- mod_pred_yobgender_values %>%
mutate(Formant = factor(Formant, levels = c("F2", "F1"))) %>%
ggplot(aes(x = Decade, y = fit, colour = Formant, linetype = Gender, label = Gender, fill = Formant)) +
geom_text(data = gam_intercepts.tmp_long %>%
mutate(Formant = factor(Formant, levels = c("F2", "F1"))), aes(x = Decade, y = fit + Intercept), size = 1, alpha = 0.5) +
geom_point(data = gam_intercepts.tmp_long %>% mutate(Formant = factor(Formant, levels = c("F2", "F1"))), aes(x = Decade, y = fit + Intercept), size = 0.25, alpha = 0.1) +
geom_line(size = 1) +
geom_ribbon(aes(ymin = ll, ymax = ul), alpha = 0.2, colour = NA) +
scale_x_continuous(breaks = c(1950, 1970, 1990)) +
xlab("Year of Birth") +
ylab("Predicted formant values (Lobanov)") +
facet_grid(Formant~Vowel) +
theme_bw() +
theme(legend.position = "top", axis.text = element_text(size = 12), axis.title = element_text(size = 14, face = "bold"), strip.text = element_text(size = 12, face = "bold")) +
guides(linetype=guide_legend(override.aes=list(fill=NA)))
sound_change_plot_smooth_gender
ggsave(plot = sound_change_plot_smooth_gender, filename = "sound_change_gam_gender.png", width = 10, height = 5, dpi = 600)
library(tidyverse)
library(emuR)
library(tools)
library(rio)
library(ggplot2)
library(magrittr)
library(htmltools)
library(joeyr)
library(knitr)
# create an emuDB from this text + audio
convert_txtCollection(dbName = "testDb",
sourceDir = "./testDB",
targetDir = ".")
# load this db
db <- load_emuDB("testDb_emuDB")
# run forced aligment using BAS MAUS tools in R
runBASwebservice_all(db,
transcriptionAttributeDefinitionName = "transcription",
language ="ltz-LU",
verbose = TRUE,
runMINNI = FALSE,
resume = TRUE,
patience = 3)
# display the overview of the structure and content
summary(db)
# open the database in a webviewer
serve(db)
# normalise the length
# td_vowels_norm = normalize_length(td_vowels %>% select(-duration, -length), colNames = c("T1", "T2"))
# do some cleaning
# exclude words spoken by another (male) speaker
# td_vowels_norm <- td_vowels_norm %>%
#  filter(!str_detect(bundle, "^[CDDEF].*"))
# save this dataframe
#saveRDS(td_vowels_norm, file ="td_vowels_norm.RDS")
# load this data frame
td_vowels_norm <- readRDS("td_vowels_norm.RDS")
# normalise the length
td_vowels_norm = normalize_length(td_vowels %>% select(-duration, -length), colNames = c("T1", "T2"))
# get formant values for those segments
# either from pre-generated Praat-Track
td_vowels = get_trackdata(db, all_vowels,
ssffTrackName = "praatFms",
resultType = "tibble")
# add new columns for length, either long or short
longMonophthongs$length <- "long"
# get "dft" track data for these segments
a_vowels = get_trackdata(emuDBhandle = db,
seglist = sl,
ssffTrackName = "MEDIAFILE_SAMPLES",
verbose = TRUE)
# load database
db = load_emuDB("/Users/peter.gilles/Documents/_Daten/LOD-emuDB/lod_emuDB")
# for testing purposes, use this smaller database in the Github folder
#db = load_emuDB("lod_emuDB")
# display the overview of the structure and content
summary(db)
sl = query(db, query = "[ ORT == 'Aarbecht']")
sl
serve(db, seglist = sl)
knitr::include_graphics(rep("emu-sdms.png"))
knitr::include_graphics(rep("hierarchy.png"))
sl = query(db, query = "[ ORT =~ 'Aarbecht.*']")
sl
sl = query(db, query = "[ ORT =~ 'Aarbecht.*' ^ #MAU=='aː']")
sl
sl = query(db, query = "[ MAU == e -> MAU == k ]")
# print only the first 100 rows
sl[1:100, ]
sl = query(db, query = "[ #MAU == e -> MAU == k ]")
# print only the first 100 rows
sl[1:100, ]
# requery_seq()
# query all "m" phonetic items
sl_m = query(db, "MAU == m")
# sequential requery (left shift result by 1 (== offset of -1))
# and hence retrieve all phonetic items directly preceeding
# all "m" phonetic items
sl_req_n <- requery_seq(db,
seglist = sl_m,
offset = -1)
sl_req_n
# query all long monophthongs
sl = query(db, "MAU == longMonophthongs")
sl
# query all "aː" phonetic items
#
sl = query(db, "MAU == aː")
# instead of all 7,000 vowels take only 6
sl = sl[100:105, ]
# get "dft" track data for these segments
a_vowels = get_trackdata(emuDBhandle = db,
seglist = sl,
ssffTrackName = "MEDIAFILE_SAMPLES",
verbose = TRUE)
# plot oscillogram
ggplot(data = a_vowels) +
# define the df columns for the x and y values
aes(y = T1, x = times_rel) +
# line chart
geom_line() +
# sl_rowIdx groups all rows in a data frame belonging to the same segment
# labels contains the label of the segment
facet_wrap(~ sl_rowIdx + labels)
# query all words beginning with 'Fluch'
#
sl = query(db, query = "[ ORT =~ 'Fluch.*']")
# get "f0" track data for these segments, in this case calculated on the fly
fluch_words = get_trackdata(emuDBhandle = db,
seglist = sl,
# using emuR's Michel Scheffers’ Modified Harmonic Sieve algorithm
onTheFlyFunctionName = "mhsF0",
verbose = TRUE)
# plot f0 tracks
ggplot(data = fluch_words) +
# define the df columns for the x and y values
# T1 here is the f0 value
aes(y = T1, x = times_rel) +
# line chart
geom_line() +
# sl_rowIdx groups all rows in a data frame belonging to the same segment
# labels contains the label of the segment
facet_wrap(~ sl_rowIdx + labels)
# query all long and short vowels
longMonophthongs = query(db, "MAU == longMonophthongs")
shortMonophthongs = query(db, "MAU == shortMonophthongs")
# bind the two together to one segment list sl
sl = rbind(longMonophthongs, shortMonophthongs)
# print the count; number of rows
nrow(longMonophthongs)
nrow(shortMonophthongs)
# calculate durations
duration_long = longMonophthongs$end - longMonophthongs$start
duration_short = shortMonophthongs$end - shortMonophthongs$start
# calculate mean and standard deviation
paste("The mean duration for long monophthongs in the databse is", round(mean(duration_long)), "ms. The standard deviation is:", sd(duration_long), ".")
paste("The mean duration for short monophthongs in the databse is", round(mean(duration_short)), "ms. The standard deviation is:", sd(duration_short), ".")
head(longMonophthongs)
# add new columns for length, either long or short
longMonophthongs$length <- "long"
shortMonophthongs$length <- "short"
# then merge the two data frame into a single one
all_vowels <- rbind(longMonophthongs, shortMonophthongs)
# add a new colum for segment duration
all_vowels$duration <- round(all_vowels$end - all_vowels$start)
# todo: keep propper sl throughout, will be needed later for requeries!
sl <- all_vowels %>% filter(!str_detect(bundle, "^[CDDEF].*"))
sl$length <- NULL
sl$duration <- NULL
duration_vowels <- all_vowels %>%
group_by(labels, length) %>%
summarise(mean = mean(duration), sd = sd(duration))
duration_vowels
# basic setting for ggplot with data and aesthetics
ggplot(data = duration_vowels, aes(x= labels, y= mean, fill = length)) +
geom_bar(stat="identity", position=position_dodge()) +
# add errorbars
geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
position=position_dodge(.9)) +
theme_minimal()
# get formant values for those segments
# either from pre-generated Praat-Track
td_vowels = get_trackdata(db, all_vowels,
ssffTrackName = "praatFms",
resultType = "tibble")
saveRDS(td_vowels, file ="td_vowels.RDS")
# normalise the length
td_vowels_norm = normalize_length(td_vowels %>% select(-duration, -length), colNames = c("T1", "T2"))
# do some cleaning
# exclude words spoken by another (male) speaker
td_vowels_norm <- td_vowels_norm %>%
filter(!str_detect(bundle, "^[CDDEF].*"))
# save this dataframe
saveRDS(td_vowels_norm, file ="td_vowels_norm.RDS")
formant_examples <- td_vowels_norm %>%
filter(sl_rowIdx == "722" | sl_rowIdx == "21702" | sl_rowIdx == "11191")
ggplot(data=formant_examples) +
geom_smooth(aes(x = times_norm, y = T1, col = labels, group = labels)) +
geom_smooth(aes(x = times_norm, y = T2, col = labels, group = labels)) +
labs(x = "Duration (normalized)", y = "F1 + F2 (Hz)") +
ggtitle("Example formants F1, F2 the three corner vowels") +
facet_wrap(~ labels)
vowel_midpoints = td_vowels_norm %>%
filter(times_norm == 0.4)
vowel_midpoints$labels <-   as.factor(vowel_midpoints$labels)
# convert Hertz to Bark
# convert T1, T2, T3 to Bark
td_vowels_norm$T1 <- emuR::bark(td_vowels_norm$T1)
td_vowels_norm$T2 <- emuR::bark(td_vowels_norm$T2)
# insert new columns from requeries to have the info about the next and next_next and previous label after the vowel available in the dataframe
vowel_midpoints$next_label = as.factor(requery_seq(db, seglist = sl, offset=1)$labels)
vowel_midpoints$next_next_label = as.factor(requery_seq(db, seglist = sl, offset=2, ignoreOutOfBounds =TRUE)$labels)
vowel_midpoints$word = requery_hier(db, seglist = sl, level="ORT")$labels
vowel_midpoints$previous_label <- as.factor(requery_seq(db, seglist = sl, offset= -1)$labels)
saveRDS(vowel_midpoints, "vowel_midpoints.RDS")
# insert new columns from requeries to have the info about the next and next_next and previous label after the vowel available in the dataframe
# vowel_midpoints$next_label = as.factor(requery_seq(db, seglist = sl, offset=1)$labels)
# vowel_midpoints$next_next_label = as.factor(requery_seq(db, seglist = sl, offset=2, ignoreOutOfBounds =TRUE)$labels)
# vowel_midpoints$word = requery_hier(db, seglist = sl, level="ORT")$labels
# vowel_midpoints$previous_label <- as.factor(requery_seq(db, seglist = sl, offset= -1)$labels)
#
# saveRDS(vowel_midpoints, "vowel_midpoints.RDS")
vowel_midpoints <- readRDS("vowel_midpoints.RDS")
head(vowel_midpoints)
# takes too long: do not run with full dataset!
ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database")
library(qs)
# takes too long: do not run with full dataset!
plot_vowel_midpoints <- ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database") %>%
qsave("plot_vowel_midpoints.qs")
# takes too long: do not run with full dataset!
plot_vowel_midpoints <- ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database") %>%
qsave("plot_vowel_midpoints.qs")
# takes too long: do not run with full dataset!
plot_vowel_midpoints <- ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database")
# takes too long: do not run with full dataset!
plot_vowel_midpoints <- ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database")
qsave(plot_vowel_midpoints, "plot_vowel_midpoints.qs")
# plot from saved ggplot
qread("plot_vowel_midpoints.qs")
ggsave(plot_vowel_midpoints, "plot_vowel_midpoints.png")
# takes too long: do not run with full dataset!
ggplot(vowel_midpoints) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
ggtitle("Scatter plot of all vowels in the LOD database")
ggsave("plot_vowel_midpoints.png")
without_outliers <- vowel_midpoints %>%
select(word, previous_label, labels, next_label, next_next_label, T1, T2, times_rel) %>%
group_by(labels) %>%
filter(!find_outliers(T1, T2, times_rel, keep = 0.85))
# outlier computations takes also a while
# to be on the safe side, also save this dataframe to disk
saveRDS(without_outliers, file="without_outliers.RDS")
ggplot(without_outliers, aes(x = T2, y = T1, color=labels)) +
geom_density2d(aes(label= labels)) +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Contour plot of all vowels in the LOD database")
# plot centroids and ellipses
centroid = without_outliers %>%
group_by(labels) %>%
summarize(F1=mean(T1), F2=mean(T2))
ggplot(without_outliers) +
aes(x=T2,y=T1, col=labels,label=labels)+
stat_ellipse() +
geom_text(data=centroid,aes(x=F2,y=F1)) +
scale_y_reverse() + scale_x_reverse() +
labs(x = "F2 (Hz)", y = "F1 (Hz)") +
theme(legend.position="none")  +
ggtitle("Dispersion of vowels in Luxembourgish")
ggplot(without_outliers %>% filter(!(labels =="ɐ" | labels == 'ə' | labels == 'ɔː'))) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Scatter plot of all vowels in the LOD database") +
facet_wrap(~ labels)
ggplot(without_outliers, aes(x = T2, y = T1, color=labels)) +
geom_density2d(aes(label= labels)) +
# add vowel labels
geom_text(aes(label= labels)) +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Contour plot of all vowels in the LOD database")
ggplot(without_outliers, aes(x = T2, y = T1, color=labels)) +
geom_density2d(aes(label= labels)) +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Contour plot of all vowels in the LOD database")
ggplot(without_outliers %>% filter(!(labels =="ɐ" | labels == 'ə' | labels == 'ɔː'))) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_density2d(aes(label= labels)) +
#geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Scatter plot of all vowels in the LOD database") +
facet_wrap(~ labels)
merger <- readRDS("e_merger_data.RDS")
View(without_outliers)
e_merger_data <- without_outliers %>%
filter(labels %in% c("e", "ə"))
View(e_merger_data)
ggplot(merger) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Scatter plot of the vowels [ə] and [e] in the LOD database") +
facet_wrap(~ next_label)
saveRDS(e_merger_data, "e_merger_data.RDS")
merger <- readRDS("e_merger_data.RDS")
ggplot(merger) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Scatter plot of the vowels [ə] and [e] in the LOD database") +
facet_wrap(~ next_label)
e_merger_data <- without_outliers %>%
filter(labels %in% c("e", "ə")) %>%
filter(next_label %in% c("ɕ", "ʃ"))
saveRDS(e_merger_data, "e_merger_data.RDS")
merger <- readRDS("e_merger_data.RDS")
ggplot(merger) +
aes(x = T2, y = T1, label = labels, col = labels) +
geom_text() +
scale_y_reverse() +
scale_x_reverse(breaks = seq(from=7, to=14, by=1), minor_breaks = NULL) +
labs(x = "F2 (Bark)", y = "F1 (Bark)") +
ggtitle("Scatter plot of the vowels [ə] and [e] in the LOD database") +
facet_wrap(~ next_label)
knitr::include_graphics(rep("pillai_example.png"))
# select rows for the two sounds
e_ch_vowels <- merger %>%
filter((labels == "e" & next_label =="ɕ"))
e_sch_vowels <- merger %>%
filter((labels == "ə" & next_label =="ʃ"))
# new df with the selected rows
vowels <- rbind(e_ch_vowels, e_sch_vowels)
# calculate the Pillai score
pillai(cbind(T1, T2) ~ labels, data = vowels)
knitr::include_app("https://petergill.shinyapps.io/shinyplay/")
knitr::include_app("https://petergill.shinyapps.io/shinyplay/")
knitr::include_app("https://petergill.shinyapps.io/shinyplay/")
#knitr::include_app("https://petergill.shinyapps.io/shinyplay/")
shinyAppDir(
system.file("~/Documents/_Daten/vowel_explorer/", package="shiny"),
options = list(width = "100%", height = 700)
)
shiny::shinyAppDir(
system.file("~/Documents/_Daten/vowel_explorer/", package="shiny"),
options = list(width = "100%", height = 700)
)
#knitr::include_app("https://petergill.shinyapps.io/shinyplay/")
shiny::shinyAppDir(
system.file("/Users/peter.gilles/Documents/_Daten/vowel_explorer", package="shiny"),
options = list(width = "100%", height = 700)
)
library(tidyverse)
library(emuR)
library(tools)
library(rio)
library(ggplot2)
library(magrittr)
library(htmltools)
library(joeyr)
library(knitr)
# create an emuDB from this text + audio
convert_txtCollection(dbName = "testDb",
sourceDir = "./testDB",
targetDir = ".")
# load this db
db <- load_emuDB("testDb_emuDB")
# run forced aligment using BAS MAUS tools in R
runBASwebservice_all(db,
transcriptionAttributeDefinitionName = "transcription",
language ="ltz-LU",
verbose = TRUE,
runMINNI = FALSE,
resume = TRUE,
patience = 3)
# open the database in a webviewer
serve(db)
# display the overview of the structure and content
summary(db)
reticulate::repl_python()
knitr::include_graphics(rep("pillai_example.png"))
knitr::include_graphics(rep("pillai_example.png"))
reticulate::repl_python()
